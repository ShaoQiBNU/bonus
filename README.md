牛客网发奖金
==========
# 一. 问题描述

> 狐进行了一次黑客马拉松大赛，全公司一共分为了N个组，每组一个房间排成一排开始比赛，比赛结束后没有公布成绩，但是每个组能够看到自己相邻的两个组里比自己成绩低的组的成绩，比赛结束之后要发奖金，以1w为单位，每个组都至少会发1w的奖金，另外，如果一个组发现自己的奖金没有高于比自己成绩低的组发的奖金，就会不满意，作为比赛的组织方，根据成绩计算出至少需要发多少奖金才能让所有的组满意。每组数据先输入N，然后N行输入N个正整数，每个数表示每个组的比赛成绩。输出至少需要多少w的奖金。例如：

```
10
20 
32 
12 
32 
45 
11 
21 
31 
41 
33

输出 20
```

# 二. 求解

> 求解过程分为两步：首先将所有组的奖金b和c初始化为1w，第一步进行正序操作，如果a[i+1]>a[i]，则b[i+1]=b[i]+1；第二步，从后向前进行逆序操作，如果a[i]>a[i+1]，则c[i]=c[i+1]+1；第三步，比较b[i]和c[i]的大小，取两者的最大值作为a[i]最终的奖金。之所以要进行逆序操作，主要是为了考虑降序的情况，例如11 21 32 54 33 22 11，如果只考虑正序操作，会导致答案错误。解决办法的是一次按照正常的顺序遍历，另一次倒序遍历，然后比较两个奖金数组的值，取较大的值即可。代码如下：

```C++
#include<iostream>
#include<vector>
using namespace std;
int main()
{
    int n;
    while(cin>>n)
    {
        vector<int>a(n,0);

        for(int i=0;i<n;i++)
            cin>>a[i];


        vector<int>b(n,1);

        for(int i=1;i<n;i++)//从前往后
            if(a[i]>a[i-1])
                b[i]=b[i-1]+1;

        for(int i=n-2;i>=0;i--)//从后往前
            if(a[i]>a[i+1]&&b[i]<b[i+1]+1)
                b[i]=b[i+1]+1;

        long sum=0;
        for(int i=0;i<n;i++)
            sum+=b[i];

         cout<<sum<<endl;
    }
}
```

